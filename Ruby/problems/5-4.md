# 問題5-4: Todoアプリのモデル設計

## 課題内容

これまで学んだクラス、継承、モジュールの知識を総動員して、実践的なTodoアプリのモデルを設計しましょう。

### 要件

以下の仕様でクラスとモジュールを実装してください：

1. **`Timestampable` モジュール**
   - `created_at` 属性（読み取り専用）を提供
   - `set_timestamp` メソッド: `created_at` に現在時刻を設定
   - このモジュールを `include` したクラスで使える

2. **`Todo` クラス**
   - `Timestampable` モジュールをMixin
   - 属性:
     - `title`: タイトル（読み取り専用）
     - `completed`: 完了状態（読み書き可能、デフォルト `false`）
     - `created_at`: 作成日時（Timestampable から）
   - 初期化: `title` をキーワード引数で受け取る
     - 初期化時に `set_timestamp` を呼び出す
   - メソッド:
     - `complete!`: 完了状態を `true` にする
     - `completed?`: 完了状態を返す
     - `info`: `"[完了] タイトル"` または `"[未完了] タイトル"` を返す

3. **`TodoList` クラス**
   - 属性:
     - `name`: リスト名（読み取り専用）
     - `todos`: Todo の配列（外部から直接アクセス不可）
   - 初期化: `name` をキーワード引数で受け取る
   - メソッド:
     - `add_todo(title)`: 新しいTodoを作成してリストに追加
     - `complete_todo(index)`: 指定インデックスのTodoを完了にする
     - `all_todos`: 全てのTodoの配列を返す
     - `completed_todos`: 完了したTodoの配列を返す
     - `incomplete_todos`: 未完了のTodoの配列を返す
     - `summary`: サマリー文字列を返す
       - 形式: `"リスト名: X個のタスク（完了: Y個、未完了: Z個）"`

### テストケース
```ruby
# TodoList の作成
list = TodoList.new(name: "今日のタスク")

# Todo の追加
list.add_todo("Ruby の勉強")
list.add_todo("買い物に行く")
list.add_todo("メールを返信")

# 全てのTodo
p list.all_todos.map(&:info)
# => ["[未完了] Rubyの勉強", "[未完了] 買い物に行く", "[未完了] メールを返信"]

# Todo の完了
list.complete_todo(0)  # 最初のTodoを完了
list.complete_todo(2)  # 3番目のTodoを完了

# 完了・未完了の確認
p list.completed_todos.map(&:info)
# => ["[完了] Rubyの勉強", "[完了] メールを返信"]

p list.incomplete_todos.map(&:info)
# => ["[未完了] 買い物に行く"]

# サマリー
p list.summary
# => "今日のタスク: 3個のタスク（完了: 2個、未完了: 1個）"

# 個別のTodoの確認
todo = list.all_todos.first
p todo.title
# => "Rubyの勉強"

p todo.completed?
# => true

p todo.created_at.class
# => Time
```

### ヒント
- **Time.now**: 現在時刻を取得
- **配列への追加**: `@todos << todo` または `@todos.push(todo)`
- **配列のフィルタリング**: `select { |todo| todo.completed? }`
- **配列のサイズ**: `array.size` または `array.length`
- **モジュールのメソッド**: モジュール内で定義したメソッドは `include` したクラスで使える
- **インデックスアクセス**: `@todos[index]`
- **破壊的メソッド**: `!` で終わるメソッドは状態を変更する慣習

### 学習ポイント
この問題を通して以下を学びます：
- 実践的なクラス設計
- モジュールによる機能の共有
- カプセル化（内部状態の隠蔽）
- オブジェクト間の協調
- 配列を使ったコレクション管理
- メソッド名の命名規則（`?`, `!`）

---

それでは実装してみてください！モジュール1つ、クラス2つを完成させてください。