問題4-3: カスタムイテレータの実装
課題内容
実用的なカスタムイテレータを実装し、yield とブロックの理解を深めましょう。
要件
以下の3つのメソッドを実装してください：

each_cons(array, n)

配列から連続するn個の要素をまとめて、順次ブロックに渡す
Rubyの each_cons メソッドと同じ動作
yield を使って実装


batch_process(array, batch_size)

配列を指定サイズごとに分割し、各バッチをブロックに渡す
最後のバッチは指定サイズより小さくてもOK
yield を使って実装


with_progress(array)

配列の各要素を処理する際に、進捗状況を表示する
ブロックには要素と進捗情報（現在位置/全体数）を渡す
yield を使って実装



テストケース
ruby# each_cons のテスト
each_cons([1, 2, 3, 4, 5], 3) do |group|
  p group
end
# 出力:
# [1, 2, 3]
# [2, 3, 4]
# [3, 4, 5]

each_cons(["a", "b", "c", "d"], 2) do |group|
  p group
end
# 出力:
# ["a", "b"]
# ["b", "c"]
# ["c", "d"]

# batch_process のテスト
batch_process([1, 2, 3, 4, 5, 6, 7], 3) do |batch|
  p batch
end
# 出力:
# [1, 2, 3]
# [4, 5, 6]
# [7]

batch_process(["a", "b", "c", "d", "e"], 2) do |batch|
  puts "処理中: #{batch.join(", ")}"
end
# 出力:
# 処理中: a, b
# 処理中: c, d
# 処理中: e

# with_progress のテスト
with_progress(["タスクA", "タスクB", "タスクC"]) do |task, progress|
  puts "#{progress} #{task}を処理中"
end
# 出力:
# [1/3] タスクAを処理中
# [2/3] タスクBを処理中
# [3/3] タスクCを処理中

with_progress([10, 20, 30, 40]) do |num, progress|
  puts "#{progress} 値: #{num}"
end
# 出力:
# [1/4] 値: 10
# [2/4] 値: 20
# [3/4] 値: 30
# [4/4] 値: 40
ヒント

each_cons: インデックスを使って、i から i+n-1 までの要素をスライス

array[i, n] または array[i...i+n] でスライスできます


batch_process: each_slice のような動作。カウンタで現在位置を追跡
with_progress: 進捗文字列は "[現在/全体]" の形式

array.size で全体数を取得


範囲チェック: 配列の範囲外にアクセスしないよう注意

学習ポイント
この問題を通して以下を学びます：

より複雑なイテレータの実装
配列のスライス操作
ループカウンタの活用
文字列フォーマット
実用的なイテレータパターン